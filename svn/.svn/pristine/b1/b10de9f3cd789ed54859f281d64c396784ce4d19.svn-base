#include "matrix.h"
/*//
 *
class MatrixException{
private:
    const std::string err_;
public:
    const std::string & what();
};

class Matrix{
private:
    int32_t **data_;
    size_t rows_, cols_;
public:
    Matrix();
    void load(std::string fname);
    void print();
    void add(const Matrix &m);
    void mul(const Matrix &m);
    void elem(int i, int j);
};

*/

using namespace std;

// MatrixException

MatrixException::MatrixException(const std::string &err)
        : err_(err)
{}

void MatrixException::print(ostream &out) {
    out << err_ << '\n';
}

const std::string& MatrixException::get() {
    return err_;
}

// Matrix

Matrix::Matrix()
        : data_(nullptr)
        , rows_(0)
        , cols_(0)
{}

void Matrix::alloc(int rows, int cols) {
    if (rows_ == rows && cols_ == cols)
        return;
    delete [] data_;
    data_ = new int32_t*[rows];
    for (int i = 0; i < rows; ++i)
        data_[i] = new int32_t[cols]();
    rows_ = rows;
    cols_ = cols;
}



void Matrix::load(std::string fname) {
    ifstream in(fname);
    int rows, cols;
    in >> rows >> cols;
    alloc(rows, cols);
    for (int i = 0; i < rows_; ++i)
        for (int j = 0; j < cols_; ++j)
            in >> data_[i][j];
}

void Matrix::print() {
    for (int i = 0; i < rows_; ++i) {
        for (int j = 0; j < cols_; ++j)
            cout << data_[i][j] << ' ';
        cout << '\n';
    }
}

void Matrix::add(const Matrix &m) {
    if (rows_ != m.rows_ || cols_ != m.cols_)
        throw MatrixException("ADD: dimensions do not match.");
    for (int i = 0; i < rows_; ++i)
        for (int j = 0; j < cols_; ++j)
            data_[i][j] += m.data_[i][j];
}

void Matrix::mul(const Matrix &m) {
    if (cols_ != m.rows_)
        throw MatrixException("MUL: #arg1.columns != #arg2.rows.");
    Matrix tmp;
    tmp.alloc(rows_, m.cols_);
    for (int i = 0; i < rows_; ++i)
        for (int j = 0; j < m.cols_; ++j)
            for (int q = 0; q < cols_; ++q)
                tmp.data_[i][j] += data_[i][q] * m.data_[q][j];
    swap(tmp);
}

void Matrix::swap(Matrix &m) {
    std::swap(rows_, m.rows_);
    std::swap(cols_, m.cols_);
    int32_t **tmp = data_;
    data_ = m.data_;
    m.data_ = tmp;
}

void Matrix::elem(int i, int j) {
    if (i < 0 || rows_ <= i || j < 0 || cols_ <= j)
        throw MatrixException("ACCESS: bad index.");
    cout << data_[i][j] << '\n';
}
